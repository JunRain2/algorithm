# 정수형
# 지수 표현
a = 1e9  # 1000000000.0
print(a)

a = 72.25e1  # 725.5
print(a)

a = 0.3 + 0.6
print(a)

if a == 0.9:
    print(True)
else:
    print(False)  # False가 노출 -> a가 0.9에는 가깝지만 미세한 오차가 발생하기 때문

if (
    round(a, 4) == 0.9
):  # round()를 통해 반올림하여 원하는 값을 얻음 -> 두 번째 인수의 경우, 반올림하고자 하는 위치 - 1을 하면됨, 즉 5번째 위치까지 반올림한 것
    print(True)
else:
    print(False)

a = 7
b = 3
print(a / b)  # 나누기는 기본적으로 실수형을 처리
print(a // b)  # 나눈 결과의 몫만 얻을 때 -> 정수형
print(a**b)  # 거듭제곱 연산자

n = 10
a = [0] * n  # 크기가 n이고, 모든 값이 0인 1차원 리스트를 초기화
print(a)

array = [[0] * 3 for _ in range(4)]  # 리스트 컴프리헨션을 통해 2차원 리스트를 초기화
# _ -> 파이썬에서 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용
print(array)  # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]

array = [
    [0] * 4
] * 3  # 리스트 컴프리헨션을 사용하지 않고 2차원 리스트를 초기화하는 경우, 내부적으로 포함된 3개의 리스트는 모두 동일한 객체에 대한 3개의 레퍼런스로 인식
array[1][1] = 5
print(array)  # [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]

a = [1, 4, 3]

a.append(2)  # [1, 4, 3, 2]
a.sort()  # [1, 2, 3, 4]
a.sort(reverse=True)  # [4, 3, 2, 1]
a.reverse()  # [1, 2, 3, 4]
a.insert(2, 3)  # 인덱스 2에 3을 삽입 [1, 2, 3, 3, 4]
a.count(3)  # 특정 값인 데이터 개수 세기 2
a.remove(1)  # 특정 값 데이터 삭제 [2, 3, 3, 4]
a.pop()  # 특정 인덱스 데이터 추출 -> 빈 배열일 경우 맨 뒤의 값 추출 [2, 3, 3]
# append()는 O(n)인 반면 insert는 O(N)으로 남발하면 시간초과가 발생할 수 있음

a = [1, 2, 4, 5, 5, 5, 5]
remove_set = {3, 5}
result = [
    i for i in a if i not in remove_set
]  # remove_set에 포함되지 않은 값만을 저장 [1, 2, 4]

# 문자열
a = "String"
print(
    a * 3
)  # 문자열 변수를 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해진다.

# 튜플
# 리스트와 비슷, but 한 번 선언된 값을 절대로 변경할 수 없다. 소괄호(())를 이용
# 그래프 알고리즘을 구현할 때 자주 사용
# 리스트에 비해 상대적으로 공간 효율적이고, 일반적으로 각 원소의 성질이 서로 다를 때 주로 사용
# 다익스트라 알고즘에서 주로 사용 -> 우선순위 큐에 들어간 값은 변경되지 않음, 튜플로 구현하여 혹시 값을 변경하는 상황을 사전에 차단
#    비용과 노드번호라는 서로 다른 성질의 데이터를 (비용, 노드번호) 의 형태로 함께 튜플로 묶어서 관리하는 것이 관례
a = (1, 2, 3, 4)
# a[2] = 7 오류 발생

# 사전 자료형
# 내부적으로 해시 테이블을 이용하므로 기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리
# 순서 X
data = dict()
data["사과"] = "Apple"
data["바나나"] = "Banana"
data["코코넛"] = "Coconut"

key_list = data.keys()  # 키 데이터만 담은 리스트
value_list = data.values()  # 값 데이터만 담은 리스트

# 집합 자료형
# 순서 X, 중복허용 X, 특정 원소가 존재하는지를 검사하는 연산의 시간 복잡도는 O(1)
# 특정한 데이터가 이미 등장한 적이 있는지 여부를 체크할 때 매우 효과적
a = set([1, 2, 3, 4, 5])
b = {3, 4, 5, 6, 7}
print(a | b)  # 합집합
print(a & b)  # 교집합
print(a - b)  # 차집합

data = set([1, 2, 3])
data.add(4)  # 새로운 원소 추가 {1, 2, 3, 4}
data.update([5, 6])  # 새로운 원소 여러 개 추가 {1, 2, 3, 4, 5, 6}
data.remove(3)  # 특정한 값을 갖는 원소 삭제 {1, 2, 4, 5, 6}
